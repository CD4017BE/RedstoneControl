#PARSE_ESCAPES
itemGroup.rs_ctr=Redstone Control
# Blocks
# names & tooltips
tile.rs_ctr.rs_port\:0.name=Redstone Read Socket
tile.rs_ctr.rs_port\:0.tip=Attach on block surface to read its emitted Redstone signal.\nCan be combined with other Â§6SocketÂ§7s on the same surface.\nÂ§bÂ§oSee also\: Â§6Â§oSignal ...\n\nCan be covered with a Â§asolid blockÂ§7 in Â§aoff-handÂ§7.\nOr place in Â§aoff-handÂ§7 against a Â§asolid blockÂ§7 to replace the block with a covered Â§6SocketÂ§7. Â§oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:1.name=Redstone Write Socket
tile.rs_ctr.rs_port\:1.tip=Attach on block surface to control the Redstone signal it receives.\nCan be combined with other Â§6SocketÂ§7s including another Â§6Write SocketÂ§7 on the same surface (two Write Sockets combined will emit a strong signal that penetrates solid blocks).\nÂ§bÂ§oSee also\: Â§6Â§oSignal ...\n\nCan be covered with a Â§asolid blockÂ§7 in Â§aoff-handÂ§7.\nOr place in Â§aoff-handÂ§7 against a Â§asolid blockÂ§7 to replace the block with a covered Â§6SocketÂ§7. Â§oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:2.name=Block Access Socket
tile.rs_ctr.rs_port\:2.tip=Attach on block surface to let connected devices interact with it.\nCan be combined with other Â§6SocketÂ§7s on the same surface.\nÂ§bÂ§oSee also\: Â§6Â§oBlock Reference ...\n\nCan be covered with a Â§asolid blockÂ§7 in Â§aoff-handÂ§7.\nOr place in Â§aoff-handÂ§7 against a Â§asolid blockÂ§7 to replace the block with a covered Â§6SocketÂ§7. Â§oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:3.name=Block Mirror Socket
tile.rs_ctr.rs_port\:3.tip=Attach on block to let it access the mirrored Â§9inventoryÂ§7 and Â§9fluid storageÂ§7 of a connected block through this socket.\nCan be combined with other Â§6SocketÂ§7s on the same surface.\nÂ§bÂ§oSee also\: Â§6Â§oBlock Reference ...Â§b, Â§6Â§oBlock Access Socket\n\nCan be covered with a Â§asolid blockÂ§7 in Â§aoff-handÂ§7.\nOr place in Â§aoff-handÂ§7 against a Â§asolid blockÂ§7 to replace the block with a covered Â§6SocketÂ§7. Â§oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.splitter.name=Signal 4x Splitter
tile.rs_ctr.splitter.tip=Repeats the incoming signal to four different destinations (no delay).
tile.rs_ctr.analog_comb.name=Analog Signal Combiner
tile.rs_ctr.analog_comb.tip=Combines the 4 incoming signals by outputting the one with highest value.
tile.rs_ctr.logic_comb.name=Logic Signal Combiner
tile.rs_ctr.logic_comb.tip=Combines the four incoming signals by logical Â§eORÂ§7, where the outputs will emit Â§e65536Â§7 for Â§etrueÂ§7 and Â§e0Â§7 for Â§efalseÂ§7.\nThe output as well as each individual input can be set to inverted which also gives you the other logic-gate types Â§eANDÂ§7, Â§eNANDÂ§7 and Â§eNORÂ§7.
tile.rs_ctr.xor_gate.name=XOR-Gate
tile.rs_ctr.xor_gate.tip=Combines the four incoming signals by Â§eExclusive-ORÂ§7, where the outputs will emit Â§e65536Â§7 if an Â§eodd numberÂ§7 of inputs is Â§etrueÂ§7 and Â§e0Â§7 otherwise.
tile.rs_ctr.num_comb.name=Arithmetic Signal Combiner
tile.rs_ctr.num_comb.tip=Combines the 4 incoming signals by adding their values together.\nInputs can be negated which allows computing subtractions too.
tile.rs_ctr.bin_comb.name=Binary Signal Packer
tile.rs_ctr.bin_comb.tip=The output signal results from concatenating the binary representations of the 4 input signals. How many bits are taken from each input signal is configurable\:\nÂ§e1 bitÂ§7 only distinguishes between Â§e0Â§7 and Â§e1\\nÂ§e2 bitÂ§7 distinguishes between Â§e0Â§7, Â§e1Â§7, Â§e2Â§7 and Â§e3\\nÂ§e4 bitÂ§7 distinguishes the values Â§e0Â§7 - Â§e15\\nÂ§e8 bitÂ§7 distinguishes the values Â§e0Â§7 - Â§e255\nÂ§oOnly values within the given range can be losslessly retrieved later on by a Â§6Â§oBinary Signal UnpackerÂ§7Â§o.
tile.rs_ctr.bin_split.name=Binary Signal Unpacker
tile.rs_ctr.bin_split.tip=Works the opposite way of the Â§6Binary Signal PackerÂ§7\:\nThe binary representation of the input signal is split into 4 pieces of Â§e1Â§7, Â§e2Â§7, Â§e4Â§7 or Â§e8 bitÂ§7 each (depending on setting) which then form the individual output signals.\n\nÂ§oThis makes it possible to send multiple signals through a shared wire. Also the operation of a Â§6Â§oLogic Signal CombinerÂ§7Â§o in Â§eÂ§obitwiseÂ§7Â§o-mode runs for all packed signals in parallel.
tile.rs_ctr.wire_anchor.name=Wire Anchor
tile.rs_ctr.wire_anchor.tip=Â§6Signal WireÂ§7s can be attached on these to customize their path.\nÂ§oMultiple of them may be placed inside a single block.
tile.rs_ctr.processor.tip=Compact circuit that's programmable with the Â§6Circuit DesignerÂ§7.\nOffers up to Â§16 InputÂ§7 and Â§26 OutputÂ§7 ports but has less component capacity than the Â§eDIP8Â§7 version.
tile.rs_ctr.processor.name=Redstone Processor Â§eQFP12
tile.rs_ctr.editor.name=Circuit Designer
tile.rs_ctr.editor.tip=Used to program assembled Â§6ProcessorÂ§7s.
tile.rs_ctr.comparator.name=clocked Comparator
tile.rs_ctr.comparator.tip=Whenever the value of Â§eClock INÂ§7 changes, Â§eOUTÂ§7 will be updated to the current comparator value read from Â§eBlock INÂ§7. A signal supplied to Â§eThreshold INÂ§7 gets subtracted from output.\nÂ§bÂ§oSee also\: Â§6Â§oBlock Reference ...Â§b, Â§6Â§oBlock Access Socket\n\nThis device can be tuned to observe different block properties by attaching certain items on it\: See Â§9Â§oJEI usage recipesÂ§7.
tile.rs_ctr.processor2.name=Redstone Processor Â§eDIP8
tile.rs_ctr.processor2.tip=Compact circuit that's programmable with the Â§6Circuit DesignerÂ§7.\nOffers up to Â§14 InputÂ§7 and Â§24 OutputÂ§7 ports.
tile.rs_ctr.assembler.name=Processor Assembler
tile.rs_ctr.assembler.tip=Lets you add materials to a Â§6Redstone ProcessorÂ§7 to improve its complexity values.
tile.rs_ctr.power_hub.name=Energy Distributor
tile.rs_ctr.power_hub.tip=Provides energy for up to 8 attached devices.\nAcceps Forge Energy compatible power through the block's back side.\nÂ§oOnly works with capacitors installed\: See Â§9Â§oJEI usage recipesÂ§7.\nÂ§oAlthough not listed, all Forge Energy compatible items can be used as well.
tile.rs_ctr.item_translocator.name=controlled Item Translocator
tile.rs_ctr.item_translocator.tip=Â§esource/destin. Inventory INÂ§7\: the inventory to take from / put in.\nÂ§esource/destin. Slot INÂ§7\: the inventory's slot ID to interact with.\nÂ§EAmount INÂ§7\: the number of items to transfer. Â§oNegative value will transfer destin. -> source instead.\nÂ§eClock INÂ§7 triggers the transfer on value change.\nÂ§eAmount OUTÂ§7 returns number of items actually transfered.\nÂ§eEnergy INÂ§7 supplies the energy required for operation.\nÂ§bÂ§oSee also\: Â§6Â§oBlock Reference ...Â§b, Â§6Â§oBlock Access Socket
tile.rs_ctr.fluid_translocator.name=controlled Fluid Translocator
tile.rs_ctr.fluid_translocator.tip=Â§esource/destin. Tank INÂ§7\: the tank to drain from / fill in.\nÂ§EAmount INÂ§7\: the fluid volume in mB to transfer. Â§oNegative value will transfer destin. -> source instead.\nÂ§eClock INÂ§7 triggers the transfer on value change.\nÂ§eAmount OUTÂ§7 returns volume actually transfered.\nÂ§eEnergy INÂ§7 supplies the energy required for operation.\nÂ§bÂ§oSee also\: Â§6Â§oBlock Reference ...Â§b, Â§6Â§oBlock Access Socket
tile.rs_ctr.panel.name=Control Panel
tile.rs_ctr.panel.tip=The surface is divided into a 4x4 grid where different Â§6ModulesÂ§7 can be attached. Ports for connecting wires to those Modules are on the back side.\nUse a Â§6ScrewdriverÂ§7 to configure or remove modules.\nÂ§oAll installed Modules and configuration is kept when broken.
tile.rs_ctr.solar_cell.name=Solar Cell
tile.rs_ctr.solar_cell.tip=Generates energy from sunlight\nto power your pocket calculator.
tile.rs_ctr.energy_valve.name=Power Regulator
tile.rs_ctr.energy_valve.tip=Controls and measures the amount of Â§9Forge EnergyÂ§7 transfered through the device\:\nChanging the value of Â§eClock INÂ§7 starts a new Energy Packet of size Â§eRF Limit INÂ§7 and Â§eRF flow OUTÂ§7 returns the amount that was transfered from the previous Packet.
tile.rs_ctr.splitter_b.name=Block Reference 4x Splitter
tile.rs_ctr.splitter_b.tip=Repeats the incoming Â§6Block ReferenceÂ§7 to four different destinations (no delay).
tile.rs_ctr.multiplex_b.name=Block Reference Multiplexer
tile.rs_ctr.multiplex_b.tip=Selects one of the four Â§6Block ReferenceÂ§7 inputs to pass on as output depending on the value of Â§eSelect INÂ§7 if it's in range Â§e0 ... 3Â§7. Otherwise outputs no Block Reference.
tile.rs_ctr.frame.name=3D Block Frame
tile.rs_ctr.frame.tip=Used to mark areas for devices\:\nFirst define the size of the area by placing Frames at chosen distances along some axes around the device.\nThen fill in all 8 corners of the area and let the device scan. These corner blocks must stay in place, otherwise the area will become invalid again.
tile.rs_ctr.block_selector.name=3D Block Selector
tile.rs_ctr.block_selector.tip=Creates Â§6Block ReferenceÂ§7s of blocks specified by Â§eX, Y, Z coordinatesÂ§7 within an area defined by Â§63D Block FrameÂ§7s.\nCoordinate inputs are valid in range Â§e0 ... size-1Â§7 for each axis.
tile.rs_ctr.block_breaker.name=controlled Block Breaker
tile.rs_ctr.block_breaker.tip=Breaks blocks and puts any harvested items into an adjacent inventory.\nÂ§eBlock IN\:Â§7 the Block to break.\nÂ§eClock IN\:Â§7 value change triggers operation.\nÂ§eStatus OUT\:Â§7 result of the last operation\:\nÂ§e-1Â§7 \= did nothing (unbreakable/Air), Â§e0Â§7 \= successful, Â§e1Â§7 \= can't proceed (inventory full), Â§e2Â§7 \= insufficient energy.\nÂ§eEnergy IN\:Â§7 energy supply for operation.\nÂ§bÂ§oSee also\: Â§6Â§oBlock Reference ...Â§b, Â§6Â§oBlock Access SocketÂ§b, Â§63D Block Selector
tile.rs_ctr.item_placer.name=controlled Item User
tile.rs_ctr.item_placer.tip=Emulates player right click interactions.\nRight-click block to open Fake Player inventory.\nÂ§eBlock IN\:Â§7 the block location to interact with/at.\nÂ§eConfiguration IN\:Â§7 {Â§aaim UpÂ§7, Â§caim RightÂ§7, Â§fuse in AirÂ§7, Â§1no existing BlockÂ§7, Â§3SneakingÂ§7, Â§2look PitchÂ§7, Â§4look YawÂ§7, Â§6Equiped slotÂ§7} binary packed as\: Â§70bÂ§800000000Â§7_Â§aUUUUÂ§cRRRRÂ§7_Â§80Â§2Â§fAÂ§1BÂ§3SÂ§2PPÂ§4YYÂ§7_Â§800Â§6EEEEE\nÂ§eClock IN\:Â§7 value change triggers action.\nÂ§eStatus OUT\:Â§7 result of last action\: Â§e-1Â§7 \= did nothing, Â§e0Â§7 \= successful, Â§e1Â§7 \= failed, Â§e2Â§7 \= insufficient energy.\nÂ§eEnergy IN\:Â§7 energy supply for operation.\nÂ§bÂ§oSee also\: Â§6Â§oBlock Reference ...Â§b, Â§6Â§oBlock Access SocketÂ§b, Â§63D Block Selector
tile.rs_ctr.delay.name=Signal Delay Line
tile.rs_ctr.delay.tip=Outputs each of the four incoming signals by one tick (0.05s) delayed.
tile.rs_ctr.delay_b.name=Block Reference Delay Line
tile.rs_ctr.delay_b.tip=Repeats each of the four incoming Â§6Block ReferenceÂ§7s by one tick (0.05s) delayed.
tile.rs_ctr.counter.name=Counter
tile.rs_ctr.counter.tip=Increments/decrements Â§eCount OUTÂ§7 whenever Â§eClock INÂ§7 changes. If count gets out of range Â§eRange IN + 1 ... 0Â§7 or Â§e0 ... Range IN - 1Â§7 it wraps around and Â§eClock OUTÂ§7 gets flipped.\n\nÂ§oNote\: This device operates without signal delays, so consistent timing between Â§eÂ§oRange INÂ§7Â§o and Â§eÂ§oClock INÂ§7Â§o can not be guaranteed!
tile.rs_ctr.oc_adapter.name=Signal IO Controller
tile.rs_ctr.oc_adapter.tip=Adapter for Â§9Open ComputersÂ§7. Offers Â§18 inputÂ§7 and Â§28 outputÂ§7 ports. Inputs can be configured to trigger signal change events.\nAlso has Â§e4 EnergyÂ§7 ports on the back to conveniently power machines from OC network.

# chat messages
msg.rs_ctr.type=Â§cIncompatible socket type!
msg.rs_ctr.wire0=Â§cInputs can only connect to outputs and vice versa!
msg.rs_ctr.wire1=Â§cToo far away, not enough wire!
msg.rs_ctr.wire2=Â§cToo far away, max length is %d blocks!
msg.rs_ctr.wire3=Â§cFirst port doesn't exist anymore!
msg.rs_ctr.const=Â§cConstants can only connect to inputs!
msg.rs_ctr.lamp=Â§cLamps can only connect to outputs!
msg.rs_ctr.probe0=Â§cMust be connected to block first!
msg.rs_ctr.probe1=Â§cCan only connect to Block Reference inputs!
msg.rs_ctr.save_succ=Â§aCircuit Schematic successfully saved!
msg.rs_ctr.load_succ=Â§aCircuit Schematic successfully loaded!
msg.rs_ctr.invalid_file=Â§cThe selected file doesn't contain Circuit Schematic data!
msg.rs_ctr.no_file=Â§cThe selected file doesn't exist!
msg.rs_ctr.cfg_store=Â§2Configuration stored
msg.rs_ctr.cfg_load=Â§2Configuration loaded
msg.rs_ctr.copy_clr=Â§1Configuration cleared
msg.rs_ctr.cfg_invalid=Â§4Invalid configuration for component!

# Items
# names & tooltips
item.rs_ctr.wire.name=Signal Wire
item.rs_ctr.wire.tip=Â§aUseÂ§7 on signal port to attach, then Â§auseÂ§7 on another signal port of opposite polarity to connect both together.\nÂ§oRequires 1 item per block of straight distance between ports.\n\nConnections are removed by either Â§ahittingÂ§7 the port or Â§asneak usingÂ§7 it with an Â§aempty handÂ§7.
item.rs_ctr.wireless.name=Wireless Signal Connector
item.rs_ctr.wireless.tip=Like a Â§6Signal WireÂ§7 but can connect two signal ports over any distance, even across dimensions.
item.rs_ctr.constant.tip=Can be attached to an input port to supply it with a constant signal value.\nÂ§aUseÂ§7 in air to configure value.
item.rs_ctr.constant.name=Constant Plug
item.rs_ctr.lamp.name=Signal Status Lamp
item.rs_ctr.lamp.tip=Attach on output port to see its signal state.\n\nCan also be attached on a Â§6Control PanelÂ§7 as indicator lamp.\nÂ§eWidth\:Â§7 1  Â§eHeight\:Â§7 1\nÂ§ePlacements\:Â§7 anywhere 4x4
item.rs_ctr.tag.name=Wire Tag
item.rs_ctr.tag.tip=Â§aUseÂ§7 in air to set name.\nÂ§aUseÂ§7 on connected port to rename its wire connection. It will then show the name instead of an ID.
item.rs_ctr.block_wire.name=Block Reference Wire
item.rs_ctr.block_wire.tip=Connects Â§6Block ReferenceÂ§7 ports just like the Â§6Signal WireÂ§7 connects signal ports.\nÂ§oConsumes 1 item per block of straight distance between ports.\nÂ§bÂ§oSee also\: Â§6Â§oBlock Access Socket
item.rs_ctr.clock.name=Clock Plug
item.rs_ctr.clock.tip=Emits a continuous square-wave signal into the port it's attached to. Switching between Â§e65535Â§7 and Â§e0Â§7.\nÂ§aUseÂ§7 in air configure pulse width and phase.\nÂ§oAll clocks in the world are synchronized.\n\nCan also be attached on a Â§6Control PanelÂ§7 as adjustable clock.\nÂ§eWidth\:Â§7 2  Â§eHeight\:Â§7 1\nÂ§ePlacements\:Â§7 anywhere 4x4
item.rs_ctr.wire_e.name=Energy Wire
item.rs_ctr.wire_e.tip=Connects energy ports just like the Â§6Signal WireÂ§7 connects signal ports.\nÂ§oConsumes 1 item per block of straight distance between ports.
item.rs_ctr.processor.stats=Complexity\: Â§c%d Â§b%d Â§9%d Â§7Size\: Â§f%d
item.rs_ctr.wrench.name=Screwdriver
item.rs_ctr.wrench.name1=Screwdriver Â§9stored conf.
item.rs_ctr.wrench.tip=Â§aUseÂ§7 on Â§6Control PanelÂ§7 to edit a module's configuration.\nÂ§aHitÂ§7 on Â§6Control PanelÂ§7 to remove a module (works in creative, too).\nÂ§aSneak-useÂ§7 on Â§6Control PanelÂ§7 to copy a module's configuration. Â§nThen\:\nÂ§aUseÂ§7 to apply the copied configuration on a module.\nÂ§aSneak-useÂ§7 in air to clear the copied configuration.\n\nOtherwise Â§aUsageÂ§7 on blocks will rotate them.
item.rs_ctr.seg7.name=7-Segment Display Module
item.rs_ctr.seg7.tip=A 4-digit 7-Segment LED-Display Module to attach on a Â§6Control PanelÂ§7.\nProvides integrated encoder logic for decimal and hexadecimal. The Â§eOUTÂ§7 signal can be used to chain multiple modules together to display bigger numbers.\nÂ§eWidth\: Â§74  Â§eHeight\:Â§7 2\nÂ§ePlacements\:Â§7 Top, Center, Bottom
item.rs_ctr.pointer_dsp.name=Analog Display Module
item.rs_ctr.pointer_dsp.tip=An analog pointer based display module to attach on a Â§6Control PanelÂ§7.\nThe scale can be a quarter or full circle and its range is freely adjustable.\nÂ§eWidth\:Â§7 4  Â§eHeight\:Â§7 4\nÂ§ePlacements\:Â§7 Center
item.rs_ctr.slider.name=Slider Module
item.rs_ctr.slider.tip=A slider module to attach on a Â§6Control PanelÂ§7 that allows continuous selection of values in a configurable range.\nÂ§aInteractÂ§7 with the upper section of the scale for fine control.\nÂ§eWidth\: Â§74  Â§eHeight\:Â§7 2\nÂ§ePlacements\:Â§7 Top, Center, Bottom
item.rs_ctr.text\:1.name=1/4 Text Module
item.rs_ctr.text\:2.name=1/2 Text Module
item.rs_ctr.text\:3.name=3/4 Text Module
item.rs_ctr.text\:4.name=full Text Module
item.rs_ctr.text\:i.tip=Displays 4 lines of text on a Â§6Control PanelÂ§7.\nÂ§eWidth\:Â§7 \\i  Â§eHeight\:Â§7 1\nÂ§ePlacements\:Â§7 anywhere 4x4
item.rs_ctr.lever\:0.name=Lever Module
item.rs_ctr.lever\:1.name=Lamp-Switch Module
item.rs_ctr.lever\:2.name=Lamp-Button Module
item.rs_ctr.lever\:i.tip=Switches between two signal states when Â§aclickedÂ§7.\nTo be attached on a Â§6Control PanelÂ§7.\nÂ§eWidth\:Â§7 1  Â§eHeight\:Â§7 1\nÂ§ePlacement\:Â§7 anywhere 4x4
item.rs_ctr.lever\:2.tip=Stays ON after being Â§aclickedÂ§7 for a configurable time interval.\nÂ§aSneak-clickÂ§7 to turn off early.\nTo be attached on a Â§6Control PanelÂ§7.\nÂ§eWidth\:Â§7 1  Â§eHeight\:Â§7 1\nÂ§ePlacements\:Â§7 anywhere 4x4
item.rs_ctr.trigger.name=Signal Threshold Latch
item.rs_ctr.trigger.tip=A Latch that turns Â§eONÂ§7 when Â§einput > enable thresholdÂ§7 and turns Â§eOFFÂ§7 when Â§einput <\= disable thresholdÂ§7 (comparisons are flipped if enable < disable).\nBoth thresholds can be adjusted on the Â§6Control PanelÂ§7.\nÂ§eWidth\:Â§7 2  Â§eHeight\:Â§7 1\nÂ§ePlacements\:Â§7 anywhere 4x4
item.rs_ctr.scale.name=Signal Scaler
item.rs_ctr.scale.tip=A Â§6Control PanelÂ§7 component that applies an adjustable scale factor to a signal.\nÂ§eWidth\:Â§7 2  Â§eHeight\:Â§7 1\nÂ§ePlacements\:Â§7 anywhere 4x4
item.rs_ctr.offset.name=Signal Offset
item.rs_ctr.offset.tip=A Â§6Control PanelÂ§7 component that adds an adjustable offset to a signal.\nÂ§eWidth\:Â§7 2  Â§eHeight\:Â§7 1\nÂ§ePlacements\:Â§7 anywhere 4x4
item.rs_ctr.oscilloscope.name=Oscilloscope Screen
item.rs_ctr.oscilloscope.tip=Displays the values of 3 channels as graphs with 100 time samples each (left to right on screen) on a Â§6Control PanelÂ§7.\nThe input signal is binary packed as 0xÂ§3TTÂ§1CCÂ§2BBÂ§4AAÂ§7 (4x8bit) with channels Â§4AÂ§7, Â§2BÂ§7, Â§1CÂ§7 in range Â§e0...100Â§7 (bottom to top on screen) and Â§3TÂ§7 being a clock signal that makes the next sample enter the graph whenever it's value changes.\nThe output signal can be chained into another Oscilloscope Screen.\nÂ§eWidth\:Â§7 4  Â§eHeight\:Â§7 4\nÂ§ePlacements\:Â§7 Center\nÂ§bÂ§oSee also\: Â§6Â§oBinary Signal PackerÂ§b, Â§6Â§oSignal ScalerÂ§b, Â§6Â§oSignal Offset
item.cd4017be.m\:battery.name=Redstone Battery
item.cd4017be.m\:actuator.name=Telekinetic Actuator
item.cd4017be.m\:telekin_alloy.name=Telekinetic Alloy

#Signal port names
port.rs_ctr.rsR=Read
port.rs_ctr.rsW=Write
port.rs_ctr.i=IN
port.rs_ctr.i0=IN 0
port.rs_ctr.i1=IN 1
port.rs_ctr.i2=IN 2
port.rs_ctr.i3=IN 3
port.rs_ctr.i4=IN 4
port.rs_ctr.i5=IN 5
port.rs_ctr.i6=IN 6
port.rs_ctr.i7=IN 7
port.rs_ctr.o=OUT
port.rs_ctr.o0=OUT 0
port.rs_ctr.o1=OUT 1
port.rs_ctr.o2=OUT 2
port.rs_ctr.o3=OUT 3
port.rs_ctr.o4=OUT 4
port.rs_ctr.o5=OUT 5
port.rs_ctr.o6=OUT 6
port.rs_ctr.o7=OUT 7
port.rs_ctr.num0=positive
port.rs_ctr.num1=negative
port.rs_ctr.logic0=x > 0
port.rs_ctr.logic1=x <\= 0
port.rs_ctr.logic2=bit-wise
port.rs_ctr.logic3=bit-wise\ninverted
port.rs_ctr.logic4=OR
port.rs_ctr.logic5=NOR
port.rs_ctr.bin4=4x4bit -> 16bit
port.rs_ctr.bin2=4x2bit -> 8bit
port.rs_ctr.bin1=4x1bit -> 4bit
port.rs_ctr.bin8=4x8bit -> 32bit
port.rs_ctr.bins1=4bit -> 4x1bit
port.rs_ctr.bins2=8bit -> 4x2bit
port.rs_ctr.bins4=16bit -> 4x4bit
port.rs_ctr.bins8=32bit -> 4x8bit
port.rs_ctr.clk=Clock IN
port.rs_ctr.bi=Block IN
port.rs_ctr.ref=Threshold IN
port.rs_ctr.clock=â? %.2fs
port.rs_ctr.energy_io=Energy I/O
port.rs_ctr.energy_i=Energy IN
port.rs_ctr.energy_o=Energy OUT
port.rs_ctr.battery0=Â§cno capacitor\nÂ§cinstalled!
port.rs_ctr.battery=Â§aCharge\:\nÂ§a%.4u / %.3u
port.rs_ctr.inv0=source Inventory IN
port.rs_ctr.inv1=destin. Inventory IN
port.rs_ctr.slot0=source Slot IN
port.rs_ctr.slot1=destin. Slot IN
port.rs_ctr.am_i=Amount IN
port.rs_ctr.am_o=Amount OUT
port.rs_ctr.cfg=Configuration
port.rs_ctr.tank0=source Tank IN
port.rs_ctr.tank1=destin. Tank IN
port.rs_ctr.rf_i=RF Limit IN
port.rs_ctr.rf_o=RF Flow OUT
port.rs_ctr.brR=Get Block OUT
port.rs_ctr.brW=Mirror Block IN
port.rs_ctr.bi0=Block IN 0
port.rs_ctr.bi1=Block IN 1
port.rs_ctr.bi2=Block IN 2
port.rs_ctr.bi3=Block IN 3
port.rs_ctr.bo=Block OUT
port.rs_ctr.sel=Select IN
port.rs_ctr.z=Z-coord IN
port.rs_ctr.y=Y-coord IN
port.rs_ctr.x=X-coord IN
port.rs_ctr.show_sel0=Area Invisible
port.rs_ctr.show_sel1=Â§aArea Visible
port.rs_ctr.area0=Â§aValid Area\: %d*%d*%d
port.rs_ctr.area1=Incomplete Area\: %d*%d*%d\nÂ§6Missing %d corner Frames!
port.rs_ctr.area2=Â§cInvalid Area\: %d*%d*%d\nÂ§oInteract to scan!
port.rs_ctr.invax0=normal
port.rs_ctr.invax1=mirrored
port.rs_ctr.status=Status OUT
port.rs_ctr.place=Configuration IN
port.rs_ctr.inc=increment
port.rs_ctr.dec=decrement
port.rs_ctr.limit=Limit IN
port.rs_ctr.count=Count OUT
port.rs_ctr.clko=Clock OUT
sensor.rs_ctr.none=Comparator\nValue
sensor.rs_ctr.item=Stored Item Count
sensor.rs_ctr.fluid=Stored Fluid [mB]
sensor.rs_ctr.fe=Stored Energy [RF]
sensor.rs_ctr.eu=Stored Energy [EU]
sensor.rs_ctr.dfr-2=Draconic Fusion Reactor\n[Â°C, RF/â€°, âˆ‘mB/â€°] +/-
sensor.rs_ctr.dfr-1=Draconic Fusion Reactor\nÂ§7no Stabilizer or Injector connected!
sensor.rs_ctr.dfr0=temperature mode:\nTemperature [Â°C]
sensor.rs_ctr.dfr1=inverted temperature mode:\nStatus {-1:cold, 0:offline, 1:safety, 2:normal, 3:overheat}
sensor.rs_ctr.dfr2=containment field mode:\nField Charge [RF]
sensor.rs_ctr.dfr3=inverted containment field mode:\nField Strength [0...1000]
sensor.rs_ctr.dfr4=core saturation mode:\nCore Charge [RF]
sensor.rs_ctr.dfr5=inverted core saturation mode:\nCore Saturation [0...1000]
sensor.rs_ctr.dfr6=fuel mode:\nTotal Core Mass [mB]
sensor.rs_ctr.dfr7=inverted fuel mode:\nFuel Conversion [0...1000]
sensor.rs_ctr.hard=Block Hardness [% Stone]
sensor.rs_ctr.light=Light Levels\nBlock[0...15] + 256*Sky[0...15]
sensor.rs_ctr.grow=Crop Growth\n-1\: none, 0\: growing, 1\: mature

#Circuit gates
gate.cost=Â§8Complexity\: Â§c%d Â§b%d
gategroup.rs_ctr.io=Memory & IO
gate.rs_ctr.in=Input Socket\nÂ§7receives external signals
gate.rs_ctr.out=Output Socket\nÂ§7emits external signals
gate.rs_ctr.return=Execution End Node\nÂ§7Ensures that the connected\nÂ§7signal is evaluated.
gate.rs_ctr.read_b=Variable Read 8bit\nÂ§7Outputs the variable value set\nÂ§7in previous evaluation cycle.
gate.rs_ctr.read_s=Variable Read 16bit\nÂ§7Outputs the variable value set\nÂ§7in previous evaluation cycle.
gate.rs_ctr.read=Variable Read 32bit\nÂ§7Outputs the variable value set\nÂ§7in previous evaluation cycle.
gate.rs_ctr.write_b=Variable Write 8bit\nÂ§7Stores input in a variable to\nÂ§7feed into next evaluation cycle.\nÂ§3Â§oOperation is only performed\nÂ§3Â§owhen connected to End Node!
gate.rs_ctr.write_s=Variable Write 16bit\nÂ§7Stores input in a variable to\nÂ§7feed into next evaluation cycle.\nÂ§3Â§oOperation is only performed\nÂ§3Â§owhen connected to End Node!
gate.rs_ctr.write=Variable Write 32bit\nÂ§7Stores input in a variable to\nÂ§7feed into next evaluation cycle.\nÂ§3Â§oOperation is only performed\nÂ§3Â§owhen connected to End Node!
gate.rs_ctr.feedback=Feedback Loop 32bit\nÂ§7Variable read and write in one.\nÂ§7Basically delays a signal by one update cycle.\nÂ§3Â§oThe input/output sides on this are reversed!
gate.rs_ctr.feedback_b=Feedback Loop 8bit\nÂ§7Variable read and write in one.\nÂ§7Basically delays a signal by one update cycle.\nÂ§3Â§oThe input/output sides on this are reversed!
gate.rs_ctr.feedback_s=Feedback Loop 16bit\nÂ§7Variable read and write in one.\nÂ§7Basically delays a signal by one update cycle.\nÂ§3Â§oThe input/output sides on this are reversed!
gate.rs_ctr.array_b=Array 8bit\nÂ§7Provides a fixed sized indexable list\nÂ§7of persistent 8bit integer values.
gate.rs_ctr.array_s=Array 16bit\nÂ§7Provides a fixed sized indexable list\nÂ§7of persistent 16bit integer values.
gate.rs_ctr.array_i=Array 32bit\nÂ§7Provides a fixed sized indexable list\nÂ§7of persistent 32bit integer values.
gate.rs_ctr.aset=Array Write\nÂ§7Writes in1 into index in2 in array in3.\nÂ§7Valid indices are Â§e0 ... N-1Â§7 for array size N.\nÂ§4Â§oAccessing an invalid index causes burnout!\nÂ§3Â§oOperation is only performed\nÂ§3Â§owhen connected to End Node!
gate.rs_ctr.aget=Array Read\nÂ§7Reads the value at index in1 in array in2.\nÂ§7Valid indices are Â§e0 ... N-1Â§7 for array size N.\nÂ§4Â§oAccessing an invalid index causes burnout!
gate.rs_ctr.alen=Array Size\nÂ§7Outputs the element count\nÂ§7of the input array.
gategroup.rs_ctr.logic=Logic
gate.rs_ctr.or=OR-Gate\nÂ§7out \= in1 âˆ¨ in2\nÂ§7bitwise
gate.rs_ctr.nand=NAND-Gate\nÂ§7out \= Â¬(in1 âˆ§ in2)\nÂ§7bitwise
gate.rs_ctr.xor=XOR-Gate\nÂ§7out \= in1 âŠ» in2\nÂ§7bitwise
gate.rs_ctr.nor=NOR-Gate\nÂ§7in \= Â¬(in1 âˆ¨ in2)\nÂ§7bitwise
gate.rs_ctr.not=NOT-Gate\nÂ§7out \= Â¬in\nÂ§7bitwise
gate.rs_ctr.and=AND-Gate\nÂ§7out \= in1 âˆ§ in2\nÂ§7bitwise
gate.rs_ctr.xnor=XNOR-Gate\nÂ§7in \= Â¬(in1 âŠ» in2)\nÂ§7bitwise
gate.rs_ctr.swt=Switch\nÂ§7in1 \= true -> out \= in2\nÂ§7else -> out \= in3
gate.rs_ctr.branch=Execution Switch\nÂ§7in1 \= true -> evaluate in2\nÂ§7else -> evaluate in3
gate.rs_ctr.sequence=Execution Sequence\nÂ§7first evaluate in1\nÂ§7then evaluate in2
gate.rs_ctr.update=Update Trigger\nÂ§7Always triggers the next\nÂ§7cycle when evaluated.
gategroup.rs_ctr.comp=Comparators
gate.rs_ctr.lt0=Is Negative\nÂ§7in < 0 -> out \= true\nÂ§7else -> out \= false
gate.rs_ctr.ge0=Not Negative\nÂ§7in < 0 -> out \= true\nÂ§7else -> out \= false
gate.rs_ctr.gt0=Is Positive\nÂ§7in > 0 -> out \= true\nÂ§7else -> out \= false
gate.rs_ctr.le0=Not Positive\nÂ§7in > 0 -> out \= false\nÂ§7else -> out \= true
gate.rs_ctr.eq0=Is Zero\nÂ§7in \= 0 -> out \= true\nÂ§7else -> out \= false
gate.rs_ctr.ne0=Not Zero\nÂ§7in \= 0 -> out \= false\nÂ§7else -> out \= true
gate.rs_ctr.ne=Not Equal\nÂ§7in1 \= in2 -> out \= false\nÂ§7else -> out \= true
gate.rs_ctr.lt=Less than\nÂ§7in1 < in2 -> out \= true\nÂ§7else -> out \= false
gate.rs_ctr.eq=Equal\nÂ§7in1 \= in2 -> out \= true\nÂ§7else -> out \= false
gate.rs_ctr.ge=Greater or Equal\nÂ§7in1 < in2 -> out \= false\nÂ§7else -> out \= true
gategroup.rs_ctr.num=Arithmetic
gate.rs_ctr.cst=Constant Number\nÂ§7out \= #
gate.rs_ctr.neg=Negate\nÂ§7out \= -in
gate.rs_ctr.sub=Subtract\nÂ§7out \= in1 - in2
gate.rs_ctr.add=Add\nÂ§7out \= in1 + in2
gate.rs_ctr.div=Divide\nÂ§7out \= in1 / in2\nÂ§7rounding down\nÂ§4Â§oDiv/0 causes burnout!
gate.rs_ctr.dec=Decrement\nÂ§7out \= in - 1
gate.rs_ctr.abs=Absolute value\nÂ§7in < 0 -> out \= -in\nÂ§7else -> out \= in
gate.rs_ctr.mul=Multiply\nÂ§7out \= in1 * in2
gate.rs_ctr.inc=Increment\nÂ§7out \= in + 1
gate.rs_ctr.mod=Div Remainder\nÂ§7out \= in1 mod in2\nÂ§7sgn(out) \= sgn(in1)\nÂ§4Â§oDiv/0 causes burnout!
gate.rs_ctr.min=Minimum\nÂ§7in1 < in2 -> out \= in1\nÂ§7else -> out \= in2
gate.rs_ctr.max=Maximum\nÂ§7in1 > in2 -> out \= in1\nÂ§7else -> out \= in2
gategroup.rs_ctr.bin=Bits & Bytes
gate.rs_ctr.bsl=Bit left shift\nÂ§7out \= in1 * 2^in2
gate.rs_ctr.bsr=Bit right shift\nÂ§7out \= in1 / 2^in2
gate.rs_ctr.bitspl=Bit Splitter\nÂ§7Splits an 8-bit input value up into its individual bits.\nÂ§7Ouputs Â§etrueÂ§7 or Â§efalseÂ§7 depending on whether the bit is set.
gate.rs_ctr.bitcom=Bit Combiner\nÂ§7Composes an 8-bit output\nÂ§7value from individual bits.
gate.rs_ctr.bytespl=Byte Splitter\nÂ§7Splits a 32-bit number into four\nÂ§7signed or unsigned 8-bit numbers.
gate.rs_ctr.bytecom=Byte Combiner\nÂ§7Combines four 8-bit numbers into one 32-bit number.\nÂ§7Â§oIgnoring any higher order bits of the inputs.

# GUI
# Inventory names
gui.rs_ctr.constant.name=Set Value
gui.rs_ctr.tag.name=Label:
gui.rs_ctr.editor.name=Circuit Editor\:
gui.rs_ctr.debug.name=Debugger
gui.rs_ctr.state.name=Variables:
gui.rs_ctr.clock.name=Clock Settings
gui.rs_ctr.assembler.name=Processor Assembler
gui.rs_ctr.dsp_cfg.name=Configuration
gui.rs_ctr.item_placer.name=controlled Item User
# Gui tooltips
gui.rs_ctr.palette=Gate Palette
gui.rs_ctr.palette.open0=Open Gate Palette
gui.rs_ctr.palette.open1=Open Inventory
gui.rs_ctr.opLabel=Gate Label\nÂ§7(relevant for\nÂ§7variables & IO)
gui.rs_ctr.value=Value
gui.rs_ctr.interrupt0=changed value Â§ndoes notÂ§r trigger next cycle
gui.rs_ctr.interrupt1=changed value triggers next cycle
gui.rs_ctr.signed0=Unsigned
gui.rs_ctr.signed1=Signed
gui.rs_ctr.array_len=Number of Entries
gui.rs_ctr.array_idx=index
gui.rs_ctr.editor.title=Name of your circuit
gui.rs_ctr.editor.del=Â§4delete Gate
gui.rs_ctr.editor.new=New Schematic\nÂ§4clears the board
gui.rs_ctr.editor.compile=Compile Circuit\nÂ§aR-CÂ§7\: Debugger
gui.rs_ctr.editor.load=Import Schematic
gui.rs_ctr.editor.save=Save Schematic\nÂ§aR-CÂ§7\: export as ...
gui.rs_ctr.editor.ingreds=Circuit Complexity\:\nÂ§c%d / %d basic\nÂ§b%d / %d advanced\nÂ§9%d / %d memory
gui.rs_ctr.editor.info=Controls\nBasic Mechanics\nSignal Types\nDebugging / Testing
gui.rs_ctr.editor.info0=Â§7Â§nComponent interaction\:Â§a left-click\nÂ§7To add a component, first click on it in the palette, then on the board where you want to place it.\nÂ§7Â§oThe palette shows up in place of your inventory when enabled via button.\nÂ§aclickÂ§7 on a component on the board to select it. Configuration options will appear below the bottom left of the board.\nÂ§aclick-dragÂ§7 to move a component around [red boxes indicate collision with other components].\nÂ§7Moving a component outside the board area will delete it [bright red box].\nÂ§7Â§nPin/Trace interaction\:Â§a right-click\nÂ§7To connect two components with a trace, first Â§aclickÂ§7 an input pin [left side of a component], then optionally click a few places on the board to lay out its path and finally Â§aclickÂ§7 another component's output pin [right side].\nÂ§aclick-dragÂ§7 a trace vertex to move it.\nÂ§aHold AltÂ§7 to display traces only.
gui.rs_ctr.editor.info1=Â§7In general a circuit receives signals from external devices through its Â§6input socketsÂ§7, performs some computations on them and produces one or more results that get send back to external devices through its Â§6output socketsÂ§7. This is referred to as a Â§ecycleÂ§7.\n\nÂ§6VariablesÂ§7 allow a circuit to remember information across cycles. They consist of a Â§6writeÂ§7 component that receives a value in one cycle and a matching [same label] Â§6readÂ§7 component that spits it out again one cycle later. The read component also defines the variable's initial value. \n\nÂ§7Normally a new cycle gets evaluated with one tick delay after an input or a variable changed its value. But you can set individual Â§6variable writeÂ§7s or Â§6inputÂ§7s to not trigger a cycle if wanted.\nÂ§7Â§oNote\: changing variable values manually through the Debugger or the processor's status interface won't trigger a cycle.
gui.rs_ctr.editor.info2=Â§7Traces have different colors to indicate the type of signal being propagated which is determined by the component pins being connected\:\nÂ§4Â§n32-bit integerÂ§7\: standard number type also used by all redstone sockets. Has a valid range of Â§a-2147483648 ... 2147483647Â§7.\nÂ§5Â§n8/16-bit integerÂ§7\: supports a of range Â§a-128 ... 127Â§7 (signed) or Â§a0 ... 255Â§7 (unsigned) for 8 bit and Â§a-32768 ... 32767Â§7 (signed) or Â§a0 ... 65536Â§7 (unsigned) for 16 bit.\nÂ§9Â§nbooleanÂ§7\: a logical signal that's either Â§atrueÂ§7 or Â§afalseÂ§7. When used for integer inputs, Â§atrue -> -1Â§7 and Â§afalse -> 0Â§7, conversion in the other direction uses Â§anon zeroÂ§7 comparison.\nÂ§6Â§nfloating pointÂ§7\: represents fractional numbers, conversion rounds to nearest integer.\nÂ§8Â§ncausal relationÂ§7\: propagates no data, only controls execution flow.\nÂ§eÂ§narrayÂ§7\: reference to an integrated Â§lRÂ§7andom Â§lAÂ§7ccess Â§lMÂ§7emory to be used with Â§egetÂ§7 and Â§esetÂ§7 operations.
gui.rs_ctr.editor.info3=Â§7Although you can overwrite the circuit on a Â§6processorÂ§7 as often as you like, it is usually a good idea to first test your design with the Â§edebuggerÂ§7 before hooking it up to ... let's say, your nuclear reactor control setup.\nÂ§7The Â§edebuggerÂ§7 window is opened by Â§aright-clickÂ§7 on the Â§ecompile buttonÂ§7 (instead of left-click). In there you can feed your circuit with different input values and see how its outputs and variable states behave after executing individual cycles.\nÂ§7The debugger's variable editing feature is also available later in the Â§6processorÂ§7's Â§estatus interfaceÂ§7 (which is opened by normal interaction with the placed block).\nÂ§7Therefore also seemingly useless Â§eread-onlyÂ§7 and Â§ewrite-onlyÂ§7 variables may be used for later adjustment of parameters or getting more details about the circuit's operation.
gui.rs_ctr.debug.run0=automatic execution
gui.rs_ctr.debug.run1=manual execution
gui.rs_ctr.debug.step0=force cycle\nÂ§4Â§ostable state
gui.rs_ctr.debug.step1=run cycle\nÂ§2Â§ounstable
gui.rs_ctr.debug.reset=reset count
gui.rs_ctr.state.io=Signal IO\:
gui.rs_ctr.hex0=decimal format
gui.rs_ctr.hex1=hexadecimal format
gui.rs_ctr.interval=Interval
gui.rs_ctr.phase=Phase Offset
gui.rs_ctr.error1=Â§4Causal Loop\: input value depends on itself!\nÂ§7Â§oInsert a Â§6Â§oFeedback LoopÂ§7Â§o operator to fix this.
gui.rs_ctr.error2=Â§4incompatible data type
gui.rs_ctr.error3=Â§4missing input signal
gui.rs_ctr.error4=Â§4invalid identifier
gui.rs_ctr.error5=Â§4duplicate variable declaration
gui.rs_ctr.error6=Â§4conflicting variable data types!
gui.rs_ctr.error7=Â§4invalid value
gui.rs_ctr.error32=Â§4missing Processor
gui.rs_ctr.error33=Â§4circuit too complex\nÂ§4for given Processor
gui.rs_ctr.error34=Â§4Processor doesn't\nsupport enough I/O
gui.rs_ctr.error64=Â§6highly recommended\nÂ§6to label your IO ports
gui.rs_ctr.error65=Â§6Gate outputs are not used!
gui.rs_ctr.save_file=Export
gui.rs_ctr.load_file=Import
gui.rs_ctr.processor.run=manually trigger cycle
gui.rs_ctr.processor.power=Redstone exhaustion\:\nÂ§e%.0f %%
gui.rs_ctr.assembler.stats=Â§c%d\nÂ§b%d\nÂ§9%d\nÂ§f%d\nÂ§e%.1f cyc\nÂ§a%.1f c/s
gui.rs_ctr.assembler.stats4=Â§e%+d cap
gui.rs_ctr.assembler.stats5=Â§a%+d u/t
gui.rs_ctr.assembler.info=Processor Assembly\nRedstone Energy
gui.rs_ctr.assembler.info0=Â§7Complex circuitry requires complex Â§6ProcessorsÂ§7.\nÂ§7There are 3 different types of Â§ecomplexityÂ§7 related to different kinds of computational tasks and each can be increased by adding specific components to the Â§6ProcessorÂ§7.\nÂ§7However components take up Â§esizeÂ§7 and there is only a limited amount of it inside the Processor.\nÂ§7Note that different components not only provide different types of Â§ecomplexityÂ§7 but may also do that at different Â§esizeÂ§7 costs and have different Â§eRedstone Energy strenghtÂ§7. Â§oSee next tab.
gui.rs_ctr.assembler.info1=Â§7It seems Â§6RedstoneÂ§7 naturally builds up charge without any apparent energy source. Â§oIt's believed that it comes from radioactive decay.\nÂ§7These charges are quite weak however, enough to perform simple logic computations but they quickly deplete when signals switch rapidly as can be seen in the burn out effect of Â§6Redstone TorchesÂ§7.\nÂ§7Certain energetic materials may improve the charge strength a bit whereas trying to miniaturize circuitry and reduce material costs severely weakens it, eventually up to a point where circuits can't run stable anymore without external power supply.\nÂ§7Â§oThis is characterized by Â§eÂ§olongest tick burstÂ§7Â§o and Â§eÂ§omax continuous tick-rateÂ§7.
gui.rs_ctr.mat3=remaining size
gui.rs_ctr.mat2=memory (bytes)
gui.rs_ctr.mat1=advanced Complexity
gui.rs_ctr.mat0=basic Complexity
gui.rs_ctr.mat5=max continuous tick-rate
gui.rs_ctr.mat4=longest tick burst
gui.rs_ctr.max=scale upper limit
gui.rs_ctr.min=scale lower limit
gui.rs_ctr.uscale=Unit scale factor
gui.rs_ctr.style=Display Style
gui.rs_ctr.label=Label
gui.rs_ctr.unit=Unit
gui.rs_ctr.encoder0=raw segments encoding\:\nÂ§78-bit per digit\nÂ§e1\:Â§7 center\nÂ§e2\:Â§7 uper left\nÂ§e4\:Â§7 top\nÂ§e8\:Â§7 upper right\nÂ§e16\:Â§7 lower right\nÂ§e32\:Â§7 bottom\nÂ§e64\:Â§7 lower left\nÂ§e128\:Â§7 decimal point
gui.rs_ctr.encoder1=signed raw segments encoding\:\nÂ§7last 3 digits like Â§eraw segments encodingÂ§7 using bits 0-23.\nÂ§72 bits [24, 25] for first digit\:\nÂ§e0\:Â§7 +\nÂ§e1\:Â§7 +1\nÂ§e2\:Â§7 -\nÂ§e3\:Â§7 -1
gui.rs_ctr.encoder2=decimal encoding
gui.rs_ctr.encoder3=signed decimal encoding
gui.rs_ctr.encoder4=hexadecimal encoding
gui.rs_ctr.color=Display Color
gui.rs_ctr.dot=decimal point position
gui.rs_ctr.text=Text lines
gui.rs_ctr.align=Text alignment
gui.rs_ctr.v_off=OFF value
gui.rs_ctr.v_on=ON value
gui.rs_ctr.thr=Threshold value\nÂ§oON when above
gui.rs_ctr.thr_off=Disable threshold
gui.rs_ctr.thr_on=Enable threshold
gui.rs_ctr.incr=Increment Step
gui.rs_ctr.scale=internal scale factor
gui.rs_ctr.div0=multiply adjustment
gui.rs_ctr.div1=divide adjustment
gui.rs_ctr.ofs=actual offset
gui.rs_ctr.item_placer.slot=Equipped Item\:\nÂ§7Slot\: Â§4%d Â§8\= bits[0...5]
gui.rs_ctr.item_placer.aim=Block surface aim\:\nÂ§7right\: %d Â§8\= bits[16...19]\nÂ§7up\: %d Â§8\= bits[20...23]
gui.rs_ctr.item_placer.look=Look orientation\:\nÂ§7yaw\: Â§4%d Â§8\= bits[8...9]\nÂ§7pitch\: Â§2%d Â§8\= bits[10...11]\nÂ§7Â§orelative to Â§1Â§oSocket
gui.rs_ctr.item_placer.sneak0=Sneaking\: No\nÂ§8bit[12] \= Â§70
gui.rs_ctr.item_placer.sneak1=Sneaking\: Yes\nÂ§8bit[12] \= Â§71
gui.rs_ctr.item_placer.side0=allow existing blocks\nÂ§8bit[13] \= Â§70
gui.rs_ctr.item_placer.side1=don't allow existing blocks\nÂ§8bit[13] \= Â§71
gui.rs_ctr.item_placer.air0=Use on Blocks\nÂ§8bit[14] \= Â§70
gui.rs_ctr.item_placer.air1=Use in Air\nÂ§8bit[14] \= Â§71
gui.rs_ctr.item_placer.creative0=Creative Mode\: OFF\nÂ§8bit[7] \= Â§70
gui.rs_ctr.item_placer.creative1=Creative Mode\: ON\nÂ§8bit[7] \= Â§71

recipe.rs_ctr.circuit_mat=Processor Components
recipe.rs_ctr.battery=Capacitors
recipe.rs_ctr.sensors=Comparator tuning
recipe.rs_ctr.capacity=%.4u Charge
