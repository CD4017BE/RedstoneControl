#PARSE_ESCAPES
itemGroup.rs_ctr=Redstone Control
# Blocks
# names & tooltips
tile.rs_ctr.rs_port\:0.name=Redstone Read Socket
tile.rs_ctr.rs_port\:0.tip=Attach on block surface to read its emitted Redstone signal.\nCan be combined with a §6Write Socket§7 on the same surface.\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:1.name=Redstone Write Socket
tile.rs_ctr.rs_port\:1.tip=Attach on block surface to control the Redstone signal it receives.\nCan be combined with either a §6Read Socket§7 or another §6Write Socket§7 on the same surface (two Write Sockets combined will emit a strong signal that penetrates solid blocks).\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.splitter.name=Signal 4x Splitter
tile.rs_ctr.splitter.tip=Repeats the incoming signal to four different destinations (no delay).
tile.rs_ctr.analog_comb.name=Analog Signal Combiner
tile.rs_ctr.analog_comb.tip=Combines the 4 incoming signals by outputing the one with highest value.
tile.rs_ctr.logic_comb.name=Logic Signal Combiner
tile.rs_ctr.logic_comb.tip=Combines the for incomming signals by logical §eOR§7, where the outputs will emit §e65536§7 for §etrue§7 and §e0§7 for §efalse§7.\nThe output as well as each individual input can be set to inverted which also gives you the other logic-gate types §eAND§7, §eNAND§7 and §eNOR§7. 
tile.rs_ctr.num_comb.name=Arithmetic Signal Combiner
tile.rs_ctr.num_comb.tip=Combines the 4 incomming signals by adding their values together.\nInputs can be negated which allows computing subtractions too.
tile.rs_ctr.bin_comb.name=Binary Signal Packer
tile.rs_ctr.bin_comb.tip=The output signal results from concatenating the binary representations of the 4 input signals. How many bits are taken from each input signal is configurable\:\n§e1 bit§7 only distinguishes between §e0§7 and §e1\\n§e2 bit§7 distinguishes between §e0§7, §e1§7, §e2§7 und §e3\\n§e4 bit§7 distinguishes the values §e0§7 - §e15\\n§e8 bit§7 distinguishes the values §e0§7 - §e255\n§oOnly values within the given range can be losslessly retrieved later on by a §6§oBinary Signal Unpacker§7§o.
tile.rs_ctr.bin_split.name=Binary Signal Unpacker
tile.rs_ctr.bin_split.tip=Works the opposite way of the §6Binary Signal Packer§7\:\nThe binary representation of the input signal is split into 4 pieces of §e1§7, §e2§7, §e4§7 or §e8 bit§7 each (depending on setting) which then form the individual output signals.\n\n§oThis makes it possible to send multiple signals through a shared wire. Also the operation of a §6§oLogic Signal Combiner§7§o in §e§obitwise§7§o-mode runs for all packed signals in parallel.
tile.rs_ctr.wire_anchor.name=Wire Anchor
tile.rs_ctr.wire_anchor.tip=§6Signal Wire§7s can be attached on these to customize their path.\n§oMultiple of them may be placed inside a single block.
tile.rs_ctr.processor.tip=Compact circuit that's programmable with the §6Circuit Designer§7.\nOffers up to §16 Input§7 and §26 Output§7 ports.
tile.rs_ctr.processor.name=Redstone Processor
tile.rs_ctr.editor.name=Circuit Designer
tile.rs_ctr.editor.tip=Used to program assembled §6Processor§7s.
tile.rs_ctr.comparator.name=clocked Comparator
tile.rs_ctr.comparator.tip=Whenever the value of §eClock IN§7 changes, §eOUT§7 will be updated to the current comparator value read from §eBlock IN§7.\n§oThis device can be tuned to observe different block properties by attaching certain items on it\: See §9§oJEI usage recipes§7.
tile.rs_ctr.assembler.name=Processor Assembler
tile.rs_ctr.assembler.tip=Lets you add materials to a §6Redstone Processor§7 to improve its complexity values.
tile.rs_ctr.power_hub.name=Energy Distributor
tile.rs_ctr.power_hub.tip=Provides energy for up to 8 attached devices.\nAcceps Forge Energy compatible power through the block's back side.\n§oOnly works with capacitors installed\: See §9§oJEI usage recipes§7.\n§oAlthough not listed, all Forge Energy compatible items can be used as well.
tile.rs_ctr.item_translocator.name=clocked Item Translocator
tile.rs_ctr.item_translocator.tip=TODO

# chat messages
msg.rs_ctr.type=§cIncompatible socket type!
msg.rs_ctr.wire0=§cInputs can only connect to outputs and vice versa!
msg.rs_ctr.wire1=§cToo far away, not enough wire!
msg.rs_ctr.wire2=§cToo far away, max length is %d blocks!
msg.rs_ctr.wire3=§cFirst port doesn't exist anymore!
msg.rs_ctr.const=§cConstants can only connect to inputs!
msg.rs_ctr.lamp=§cLamps can only connect to outputs!
msg.rs_ctr.probe0=§cMust be connected to block first!
msg.rs_ctr.probe1=§cCan only connect to Block Reference inputs!
msg.rs_ctr.save_succ=§aCircuit Schematic successfully saved!
msg.rs_ctr.load_succ=§aCircuit Schematic successfully loaded!
msg.rs_ctr.invalid_file=§cThe selected file does'nt contain Circuit Schematic data!
msg.rs_ctr.no_file§cThe selected file does'nt exist!

# Items
# names & tooltips
item.rs_ctr.wire.name=Signal Wire
item.rs_ctr.wire.tip=§aUse§7 on signal port to attach, then §ause§7 on another signal port of opposite polarity to connect both together.\n§oRequires 1 item per block of straight distance between ports.\n\nConnections are removed by either §ahitting§7 the port or §asneak using§7 it with an §aempty hand§7.
item.rs_ctr.wireless.name=Wireless Signal Connector
item.rs_ctr.wireless.tip=Like a §6Signal Wire§7 but can connect two signal ports over any distance, even across dimensions.
item.rs_ctr.constant.tip=Can be attached to an input port to supply it with a constant signal value.\n§aUse§7 in air to configure value.
item.rs_ctr.constant.name=Constant Plug
item.rs_ctr.lamp.name=Signal Status Lamp
item.rs_ctr.lamp.tip=Attach on output port to see its signal state.
item.rs_ctr.tag.name=Wire Tag
item.rs_ctr.tag.tip=§aUse§7 in air to set name.\n§aUse§7 on connected port to rename its wire connection. It will then show the name instead of an ID.
item.rs_ctr.block_wire.name=Block Probe Wire
item.rs_ctr.block_wire.tip=Used to connect block faces to devices like Sensors, etc.
item.rs_ctr.clock.name=Clock Plug
item.rs_ctr.clock.tip=Emits a continuous square-wave singal into the port it's attached to. Switching between §e65535§7 and §e0§7.\n§aUse§7 in air configure pulse width and phase.\n§oAll clocks in the world are synchronized.
item.rs_ctr.wire_e.name=Energy Wire
item.rs_ctr.wire_e.tip=Connects energy ports just like the §6Signal Wire§7 connects signal ports.\n§oConsumes 1 item per block of straight distance between ports.
item.rs_ctr.processor.stats=Complexity\: §c%d §b%d §9%d §7Size\: §f%d
item.cd4017be.m\:battery.name=Redstone Battery
item.cd4017be.m\:actuator.name=Remote Actuator

#Signal port names
port.rs_ctr.rsR=Read
port.rs_ctr.rsW=Write
port.rs_ctr.i=IN
port.rs_ctr.i0=IN 0\n§oleast significant
port.rs_ctr.i1=IN 1
port.rs_ctr.i2=IN 2
port.rs_ctr.i3=IN 3\n§omost significant
port.rs_ctr.o=OUT
port.rs_ctr.o0=OUT 0\n§oleast significant
port.rs_ctr.o1=OUT 1
port.rs_ctr.o2=OUT 2
port.rs_ctr.o3=OUT 3\n§omost significant
port.rs_ctr.num0=positive
port.rs_ctr.num1=negative
port.rs_ctr.logic0=x > 0
port.rs_ctr.logic1=x <\= 0
port.rs_ctr.logic2=bit-wise
port.rs_ctr.logic3=bit-wise\ninverted
port.rs_ctr.logic4=OR
port.rs_ctr.logic5=NOR
port.rs_ctr.bin4=4x4bit -> 16bit
port.rs_ctr.bin2=4x2bit -> 8bit
port.rs_ctr.bin1=4x1bit -> 4bit
port.rs_ctr.bin8=4x8bit -> 32bit
port.rs_ctr.bins1=4bit -> 4x1bit
port.rs_ctr.bins2=8bit -> 4x2bit
port.rs_ctr.bins4=16bit -> 4x4bit
port.rs_ctr.bins8=32bit -> 4x8bit
port.rs_ctr.clk=Clock IN
port.rs_ctr.bi=Block IN
port.rs_ctr.clock=⎍ %.2fs
port.rs_ctr.energy_i=Energy IN
port.rs_ctr.energy_o=Energy OUT
port.rs_ctr.battery0=§cno capacitor\n§cinstalled!
port.rs_ctr.battery=§aCharge\:\n§a%.4u / %.3u
port.rs_ctr.inv0=source Inventory IN
port.rs_ctr.inv1=destin. Inventory IN
port.rs_ctr.slot0=source Slot IN
port.rs_ctr.slot1=destin. Slot IN
port.rs_ctr.am_i=Amount IN
port.rs_ctr.am_o=Amount OUT
sensor.rs_ctr.none=Comparator\nValue
sensor.rs_ctr.item=Stored Item Count
sensor.rs_ctr.fluid=Stored Fluid [mB]
sensor.rs_ctr.fe=Stored Energy [RF]
sensor.rs_ctr.eu=Stored Energy [EU]

#Circuit gates
gate.cost=§8Complexity\: §c%d §b%d
gategroup.rs_ctr.io=Variables & IO
gate.rs_ctr.in=Input Socket\n§7receives external sinals
gate.rs_ctr.out=Output Socket\n§7emits external signals
gate.rs_ctr.write=Variable Write\n§7Stores input in a variable to\n§7feed into next evaluation cycle
gate.rs_ctr.read=Variable read\n§7Outputs the variable value set\n§7in previous evaluation cycle.
gate.rs_ctr.i_cst=Constant Number\n§7out \= #
gategroup.rs_ctr.logic=Logic
gate.rs_ctr.or=OR-Gate\n§7out \= in1 ∨ in2\n§7bitwise
gate.rs_ctr.nand=NAND-Gate\n§7out \= ¬(in1 ∧ in2)\n§7bitwise
gate.rs_ctr.xor=XOR-Gate\n§7out \= in1 ⊻ in2\n§7bitwise
gate.rs_ctr.nor=NOR-Gate\n§7in \= ¬(in1 ∨ in2)\n§7bitwise
gate.rs_ctr.not=NOT-Gate\n§7out \= ¬in\n§7bitwise
gate.rs_ctr.and=AND-Gate\n§7out \= in1 ∧ in2\n§7bitwise
gate.rs_ctr.xnor=XNOR-Gate\n§7in \= ¬(in1 ⊻ in2)\n§7bitwise
gategroup.rs_ctr.comp=Comparators
gate.rs_ctr.nsgn=Is Negative\n§7in < 0 -> out \= -1\n§7else -> out \= 0
gate.rs_ctr.psgn=Not Negative\n§7in < 0 -> out \= 0\n§7else -> out \= -1
gate.rs_ctr.is0=Is Zero\n§7in \= 0 -> out \= -1\n§7else -> out \= 0
gate.rs_ctr.not0=Not Zero\n§7in \= 0 -> out \= 0\n§7else -> out \= -1
gate.rs_ctr.neq=Not Equal\n§7in1 \= in2 -> out \= 0\n§7else -> out \= -1
gate.rs_ctr.ls=Less than\n§7in1 < in2 -> out \= -1\n§7else -> out \= 0
gate.rs_ctr.eq=Equal\n§7in1 \= in2 -> out \= -1\n§7else -> out \= 0
gate.rs_ctr.geq=Greater or Equal\n§7in1 < in2 -> out \= 0\n§7else -> out \= -1
gategroup.rs_ctr.num=Arithmetic
gate.rs_ctr.neg=Negate\n§7out \= -in
gate.rs_ctr.sub=Subtract\n§7out \= in1 - in2
gate.rs_ctr.add=Add\n§7out \= in1 + in2
gate.rs_ctr.div=Divide\n§7out \= in1 / in2\n§7rounding down\n§4§oDiv/0 causes burnout!
gate.rs_ctr.dec=Decrement\n§7out \= in - 1
gate.rs_ctr.abs=Absolute value\n§7in < 0 -> out \= -in\n§7else -> out \= in
gate.rs_ctr.mul=Multiply\n§7out \= in1 * in2
gate.rs_ctr.inc=Increment\n§7out \= in + 1
gate.rs_ctr.mod=Div Remainder\n§7out \= in1 mod in2\n§7sgn(out) \= sgn(in1)\n§4§oDiv/0 causes burnout!
gate.rs_ctr.min=Minimum\n§7in1 < in2 -> out \= in1\n§7else -> out \= in2
gate.rs_ctr.max=Maximum\n§7in1 > in2 -> out \= in1\n§7else -> out \= in2

# GUI
# Inventory names
gui.rs_ctr.constant.name=Set Value
gui.rs_ctr.tag.name=Label:
gui.rs_ctr.editor.name=Circuit Editor\:
gui.rs_ctr.debug.name=Debugger
gui.rs_ctr.state.name=Variables:
gui.rs_ctr.clock.name=Clock Settings
gui.rs_ctr.assembler.name=Processor Assembler
# Gui tooltips
gui.rs_ctr.palette=Gate Palette
gui.rs_ctr.palette.open0=Open Gate Palette
gui.rs_ctr.palette.open1=Open Inventory
gui.rs_ctr.opLabel=Gate Label\n§7(relevant for\n§7variables & IO)
gui.rs_ctr.value=Value
gui.rs_ctr.interrupt0=changed value §ndoes not§r trigger next cycle
gui.rs_ctr.interrupt1=changed value triggers next cycle
gui.rs_ctr.editor.title=Name of your circuit
gui.rs_ctr.editor.del=§4delete Gate
gui.rs_ctr.editor.new=New Schematic\n§4clears the board
gui.rs_ctr.editor.compile=Compile Circuit\n§aR-C§7\: Debugger
gui.rs_ctr.editor.load=Import Schematic
gui.rs_ctr.editor.save=Save Schematic\n§aR-C§7\: export as ...
gui.rs_ctr.editor.ingreds=Circuit Complexity\:\n§c%d / %d basic\n§b%d / %d advanced\n§9%d / %d memory
gui.rs_ctr.editor.info=Controls\nBasic Mechanics\nDebugging / Testing
gui.rs_ctr.editor.info0=§7§nComponent interaction\:§a left-click\n§7To add a component, first click on it in the palette, then on the board where you want to place it.\n§7§oThe palette shows up in place of your inventory when enabled via button.\n§aclick§7 on a component on the board to select it. Configuration options will appear below the bottom left of the boeard.\n§aclick-drag§7 to move a component around [red boxes indicate collision with other components].\n§7Moving a component outside the board area will delete it [bright red box].\n§7§nPin/Trace interaction\:§a right-click\n§7To connect two components with a trace, first §aclick§7 an input pin [left side of a component], then optinally click a few places on the board to lay out its path and finally §aclick§7 another component's output pin [right side].\n§aclick-drag§7 a trace vertex to move it.
gui.rs_ctr.editor.info1=§7In general a circuit receives signals from external devices through its §6input sockets§7, performs some computations on them and produces one or more results that get send back to external devices through its §6output sockets§7. This is refered to as a §ecycle§7.\n\n§6Variables§7 allow a circuit to remember information across cycles. They consist of a §6write§7 component that receives a value in one cycle and a matching [same label] §6read§7 component that spits it out again one cycle later. The read component also defines the variable's initial value. \n\n§7Normally a new cycle gets evaluated with one tick delay after an input or a variable changed its value. But you can set individual §6variable write§7s or §6input§7s to not trigger a cycle if wanted.\n§7§oNote\: changing variable values manually through the Debugger or the processor's status interface won't trigger a cycle.
gui.rs_ctr.editor.info2=§7Although you can overwrite the circuit on a §6processor§7 as often as you like, it is usually a good idea to first test your design with the §edebugger§7 before hooking it up to ... let's say, your nuclear reactor control setup.\n§7The §edebugger§7 window is opened by §aright-click§7 on the §ecompile button§7 (instead of left-click). In there you can feed your circuit with different input values and see how its outputs and variable states behave after executing individual cycles.\n§7The debugger's variable editing feature is also available later in the §6processor§7's §estatus interface§7 (which is opened by normal interaction with the placed block).\n§7Therefore also seemingly useless §eread-only§7 and §ewrite-only§7 variables may be used for later adjustment of parameters or getting more details about the circuit's operation.
gui.rs_ctr.debug.run0=automatic execution
gui.rs_ctr.debug.run1=manual execution
gui.rs_ctr.debug.step0=force cycle\n§4§ostable state
gui.rs_ctr.debug.step1=run cycle\n§2§ounstable
gui.rs_ctr.debug.reset=reset count
gui.rs_ctr.state.io=Signal IO\:
gui.rs_ctr.hex0=decimal format
gui.rs_ctr.hex1=hexadecimal format
gui.rs_ctr.interval=Interval
gui.rs_ctr.phase=Phase Offset
gui.rs_ctr.error1=§4causal loop
gui.rs_ctr.error2=§4incompatible data type
gui.rs_ctr.error3=§4missing input signal
gui.rs_ctr.error4=§4invalid identifier
gui.rs_ctr.error5=§4duplicate variable declaration
gui.rs_ctr.error6=§4conflicting writes on same variable
gui.rs_ctr.error7=§4invalid value
gui.rs_ctr.error32=§4missing Processor
gui.rs_ctr.error33=§4circuit too complex\n§4for given Processor
gui.rs_ctr.error34=§4Processor doesn't\nsupport enough I/O
gui.rs_ctr.error64=§6highly recommended\n§6to label your IO ports
gui.rs_ctr.save_file=Export
gui.rs_ctr.load_file=Import
gui.rs_ctr.processor.run=manually trigger cycle
gui.rs_ctr.processor.power=Redstone exhaustion\:\n§e%.0f %%
gui.rs_ctr.assembler.stats=§c%d\n§b%d\n§9%d\n§f%d\n§e%.1f cyc\n§a%.1f c/s
gui.rs_ctr.assembler.stats4=§e%+d cap
gui.rs_ctr.assembler.stats5=§a%+d u/t
gui.rs_ctr.assembler.info=Processor Assembly\nRedstone Energy
gui.rs_ctr.assembler.info0=§7Complex circuitry requires complex §6Processors§7.\n§7There are 3 different types of §ecomplexity§7 related to different kinds of computational tasks and each can be increased by adding specific components to the §6Processor§7.\n§7However components take up §esize§7 and there is only a limited amount of it inside the Processor.\n§7Note that different components not only provide different types of §ecomplexity§7 but may also do that at different §esize§7 costs and have different §eRedstone Energy strenght§7. §oSee next tab.
gui.rs_ctr.assembler.info1=§7It seems §6Redstone§7 naturally builds up charge without any apparent energy source. §oIt's believed that it comes from radioactive decay.\n§7These charges are quite weak however, enough to perform simple logic computations but they quickly deplete when signals switch rapidly as can be seen in the burn out effect of §6Redstone Torches§7.\n§7Certain energetic materials may improve the charge strenght a bit whereas trying to miniaturize circuitry and reduce material costs severely weakens it, eventually up to a point where circuits can't run stable anymore without external power supply.\n§7§oThis is characterized by §e§olongest tick burst§7§o and §e§omax continuous tickrate§7.
gui.rs_ctr.mat3=remaining size
gui.rs_ctr.mat2=memory (bytes)
gui.rs_ctr.mat1=advanced Complexity
gui.rs_ctr.mat0=basic Complexity
gui.rs_ctr.mat5=max continuous tickrate
gui.rs_ctr.mat4=longest tick burst

recipe.rs_ctr.circuit_mat=Processor Components
recipe.rs_ctr.battery=Capacitors
recipe.rs_ctr.sensors=Comparator tuning
recipe.rs_ctr.capacity=%.4u Charge
#added by ingame editor:
#added by ingame editor:
